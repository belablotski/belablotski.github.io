+++
date = '2025-07-27T20:14:00-08:00'
draft = false
title = 'Week 30 of the year 2025'
tags = ['engineering']
+++
This Week's Challenges: 
- [From Prompt Engineering to Language Engineering: The Story of APL]({{< relref "week-2025-30.md#apl" >}})

<!--more-->

## From Prompt Engineering to Language Engineering: The Story of APL {#apl}

Almost every week, I write about an engineering challenge I've tackled. Usually, it’s about a specific technology or a tricky bug. This week, it’s about a problem that started with people and ended with me creating a new programming language.

The task sounds simple: every week, I want to find the most interesting, well-crafted, and insightful pull requests submitted by engineers in my group. I’m not just looking for the biggest features, but for the "masterpieces" — the elegant refactors, the clever bug fixes, the beautifully documented API changes that others can learn from. This is a real-world task I needed to solve.

My first thought was: "This is a perfect job for an AI agent."

### The Limits of Natural Language

I started by writing a detailed set of instructions in a markdown file. I laid out the process in phases: find the PRs, clone the repos, analyze the code for craftsmanship, categorize the changes, and finally, rank them. I was essentially "prompt engineering" a complex algorithm.

The problem was, it wasn't reproducible. Basically you can find it here https://github.com/belablotski/APL/blob/main/examples/best_prs/insructions_to_agent.md

AI is fantastic at creative tasks, but that very creativity becomes a liability when you need a deterministic, repeatable process. One day, the agent would follow my instructions to the letter. The next, it would decide to "optimize" by skipping a few PRs it deemed uninteresting, or it would interpret "code craftsmanship" in a slightly different way. The results were inconsistent. I wasn't running a script; I was having a conversation, and the outcome was never guaranteed.

I realized that describing an algorithm in a natural language document, no matter how detailed, was fundamentally unreliable for this kind of task.

### The Shift: From Instructions to a Program

This led me to a critical insight. What if I stopped *telling* the agent what to do and instead gave it a *program to execute*?

The agent's role would shift from a creative partner to a high-fidelity interpreter. It would still use its powerful reasoning engine for high-level tasks (like "analyze this diff for craftsmanship"), but the overall workflow—the sequence of steps, the loops, the state management—would be rigidly defined.

This was the birth of APL: the Agentic Programming Language. And effectively this is the first APL program https://github.com/belablotski/APL/blob/main/examples/best_prs/program_to_agent.apl

I created the first version of APL to solve my immediate problem. Instead of a page of prose, my instructions became a simple, structured YAML file.

```yaml
# APL Program: Best Pull Request Finder
# Version: 0.1

setup:
  - load_pr_list:
      from_file: "list_last_week_prs.txt"
      register: pr_urls
  - create_workspace:
      path: "./pr_analysis_workspace"
      register: workspace_path

main:
  foreach:
    in: pr_urls
    loop_var: pr_url
  run:
    - name: "Fetch PR Metadata"
      tool: shell
      command: "gh pr view {{pr_url}} --json author,title,mergeCommit"
      register: pr_metadata

    - name: "Analyze PR Contribution"
      tool: analyze_pr_diff
      register: pr_analysis
      using:
        - "categorize_change:Architectural,Feature,API,Testing,Fix,Docs"
        - "evaluate_craftsmanship:Clarity,Consistency,Comments,Maintainability,Patterns"
...
```

The logic is the same, but the execution is now completely deterministic. The `foreach` loop will always run for every single PR. The `tool` for each step is explicitly defined. The agent's job is to execute this plan, not to invent one.

It worked perfectly. The process is now reliable, repeatable, and I get a consistent analysis every week.

### APL is Now Open Source

What started as a solution to a personal engineering challenge has grown into a project I believe has much broader potential. APL is a new way to think about orchestrating AI, combining the predictability of code with the reasoning power of modern agents.

I’ve now open-sourced the first version of the Agentic Programming Language. You can find it on GitHub:

[**https://github.com/belablotski/apl**](https://github.com/belablotski/apl)

It’s still early, but the foundation is there: a simple, declarative syntax, a powerful tool system, and a runtime that enforces deterministic execution. I have a roadmap of features I want to add, borrowing concepts like functions, error handling, and even parallelism from traditional programming languages to make it even more robust.

If you've ever been frustrated by the unpredictability of complex prompts or wished you could put your AI agent's workflow into source control, I invite you to check it out, try it for your own tasks, and contribute to its development. This feels like the next step in our journey of learning how to work with AI.